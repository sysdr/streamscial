<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamSocial Producer Acknowledgment Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-2.28.0.min.js"></script>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .header { text-align: center; color: #333; margin-bottom: 30px; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .metric-card { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .metric-title { font-weight: bold; color: #333; margin-bottom: 10px; text-transform: uppercase; }
        .metric-value { font-size: 2em; font-weight: bold; margin: 10px 0; }
        .critical { color: #e74c3c; }
        .social { color: #3498db; }
        .analytics { color: #2ecc71; }
        .charts-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
        .chart-card { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
        .connected { background: #d4edda; color: #155724; }
        .disconnected { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <div class="header">
        <h1>StreamSocial Producer Acknowledgment Dashboard</h1>
        <div id="status" class="status disconnected">Connecting...</div>
    </div>

    <div class="metrics-grid">
        <div class="metric-card">
            <div class="metric-title critical">Critical Events (acks=all)</div>
            <div class="metric-value critical" id="critical-throughput">0</div>
            <div>Messages Acknowledged</div>
            <div id="critical-latency">Latency: 0ms</div>
            <div id="critical-reliability">Reliability: 100%</div>
        </div>

        <div class="metric-card">
            <div class="metric-title social">Social Events (acks=1)</div>
            <div class="metric-value social" id="social-throughput">0</div>
            <div>Messages Acknowledged</div>
            <div id="social-latency">Latency: 0ms</div>
            <div id="social-reliability">Reliability: 100%</div>
        </div>

        <div class="metric-card">
            <div class="metric-title analytics">Analytics Events (acks=0)</div>
            <div class="metric-value analytics" id="analytics-throughput">0</div>
            <div>Messages Sent</div>
            <div id="analytics-latency">Latency: 0ms</div>
            <div id="analytics-reliability">Reliability: N/A</div>
        </div>
    </div>

    <div class="charts-container">
        <div class="chart-card">
            <h3>Throughput Comparison</h3>
            <div id="throughput-chart"></div>
        </div>
        <div class="chart-card">
            <h3>Latency Comparison</h3>
            <div id="latency-chart"></div>
        </div>
    </div>

    <script>
        const socket = io();
        
        socket.on('connect', function() {
            document.getElementById('status').textContent = 'Connected to StreamSocial';
            document.getElementById('status').className = 'status connected';
        });

        socket.on('disconnect', function() {
            document.getElementById('status').textContent = 'Disconnected';
            document.getElementById('status').className = 'status disconnected';
        });

        socket.on('metrics_update', function(data) {
            console.log('Received metrics update:', data.metrics);
            updateMetrics(data.metrics);
            updateCharts(data.metrics);
        });

        function updateMetrics(metrics) {
            // Update metric cards
            for (const [type, metric] of Object.entries(metrics)) {
                const avgLatency = metric.latency.length > 0 
                    ? (metric.latency.reduce((a, b) => a + b, 0) / metric.latency.length).toFixed(2)
                    : 0;
                
                const reliability = metric.sent > 0 
                    ? ((metric.acked / metric.sent) * 100).toFixed(1)
                    : 100;

                document.getElementById(`${type}-throughput`).textContent = metric.acked;
                document.getElementById(`${type}-latency`).textContent = `Latency: ${avgLatency}ms`;
                
                if (type !== 'analytics') {
                    document.getElementById(`${type}-reliability`).textContent = `Reliability: ${reliability}%`;
                }
            }
        }

        // Chart data storage
        let chartData = {
            timestamps: [],
            critical: { throughput: [], latency: [] },
            social: { throughput: [], latency: [] },
            analytics: { throughput: [], latency: [] }
        };

        function updateCharts(metrics) {
            const now = Date.now();
            chartData.timestamps.push(now);
            
            // Keep only last 50 data points
            if (chartData.timestamps.length > 50) {
                chartData.timestamps.shift();
                chartData.critical.throughput.shift();
                chartData.critical.latency.shift();
                chartData.social.throughput.shift();
                chartData.social.latency.shift();
                chartData.analytics.throughput.shift();
                chartData.analytics.latency.shift();
            }

            // Calculate throughput and latency for each producer type
            for (const [type, metric] of Object.entries(metrics)) {
                const avgLatency = metric.latency.length > 0 
                    ? (metric.latency.reduce((a, b) => a + b, 0) / metric.latency.length)
                    : 0;
                
                // Use the current acked count as throughput (will show cumulative messages)
                const throughput = metric.acked;
                
                chartData[type].throughput.push(throughput);
                chartData[type].latency.push(avgLatency);
            }

            // Only update charts if we have data
            if (chartData.timestamps.length > 1) {
                // Update throughput chart
                const throughputData = [
                    {x: chartData.timestamps, y: chartData.critical.throughput, type: 'scatter', mode: 'lines', name: 'Critical', line: {color: '#e74c3c'}},
                    {x: chartData.timestamps, y: chartData.social.throughput, type: 'scatter', mode: 'lines', name: 'Social', line: {color: '#3498db'}},
                    {x: chartData.timestamps, y: chartData.analytics.throughput, type: 'scatter', mode: 'lines', name: 'Analytics', line: {color: '#2ecc71'}}
                ];

                // Update latency chart
                const latencyData = [
                    {x: chartData.timestamps, y: chartData.critical.latency, type: 'scatter', mode: 'lines', name: 'Critical', line: {color: '#e74c3c'}},
                    {x: chartData.timestamps, y: chartData.social.latency, type: 'scatter', mode: 'lines', name: 'Social', line: {color: '#3498db'}},
                    {x: chartData.timestamps, y: chartData.analytics.latency, type: 'scatter', mode: 'lines', name: 'Analytics', line: {color: '#2ecc71'}}
                ];

                try {
                    Plotly.react('throughput-chart', throughputData, {
                        title: 'Messages Acknowledged (Cumulative)',
                        xaxis: {title: 'Time'},
                        yaxis: {title: 'Messages'}
                    });

                    Plotly.react('latency-chart', latencyData, {
                        title: 'Average Latency (ms)',
                        xaxis: {title: 'Time'},
                        yaxis: {title: 'Latency (ms)'}
                    });
                } catch (error) {
                    console.error('Error updating charts:', error);
                }
            }
        }

        // Initialize charts
        function initCharts() {
            const throughputData = [
                {x: [], y: [], type: 'scatter', mode: 'lines', name: 'Critical', line: {color: '#e74c3c'}},
                {x: [], y: [], type: 'scatter', mode: 'lines', name: 'Social', line: {color: '#3498db'}},
                {x: [], y: [], type: 'scatter', mode: 'lines', name: 'Analytics', line: {color: '#2ecc71'}}
            ];

            const latencyData = [
                {x: [], y: [], type: 'scatter', mode: 'lines', name: 'Critical', line: {color: '#e74c3c'}},
                {x: [], y: [], type: 'scatter', mode: 'lines', name: 'Social', line: {color: '#3498db'}},
                {x: [], y: [], type: 'scatter', mode: 'lines', name: 'Analytics', line: {color: '#2ecc71'}}
            ];

            Plotly.newPlot('throughput-chart', throughputData, {
                title: 'Messages per Second',
                xaxis: {title: 'Time'},
                yaxis: {title: 'Messages/sec'}
            });

            Plotly.newPlot('latency-chart', latencyData, {
                title: 'Average Latency (ms)',
                xaxis: {title: 'Time'},
                yaxis: {title: 'Latency (ms)'}
            });
        }

        initCharts();
    </script>
</body>
</html>
